---
title: "Kolleg Europa - Network Analysis"
subtitle: "Datenauswertung Reisediplomatie-Netzwerk"
author: "Stefan Haussner"
date: "7 März 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(igraph)
library(threejs)
library(DT)
library(tidyverse)
library(reshape2)
```

```{r}
load("C:/OwnCloud/SH/Workshops_Talks/KollegEuropa_Studienstiftung_Netzwerkanalyse_Prag/R/network_analysis_KollegEuropa/data/data_preprocessed.Rdata")
#load("D:/KollegEuropa_Studienstiftung_Netzwerkanalyse_Prag/R/network_analysis_KollegEuropa/data/data_preprocessed.Rdata")
```


# Analyse des Two-Mode-Netzwerks

Es gibt verschiedene Ansätze für die Analyse von Zugehörigkeitsdaten, ohne die Umwandlung in Co-Affiliation-Netze. Da Zugehörigkeitsgraphen auch Graphen sind, liegt der naheliegende Ansatz darin, einfach alle Standardalgorithmen und -techniken des Netzwerkanalyse-Toolkits zu verwenden, die für normale Netze im Allgemeinen gelten. 

Dabei gehen wir entweder davon aus, dass die spezielle Natur von Affiliationsnetzen die Techniken nicht beeinflusst, oder wir können vorgeben, dass Bindungen innerhalb von Knotensätzen aufgetreten sein könnten und einfach nicht aufgetreten sind. Dieser Ansatz funktioniert für eine kleine Klasse von Methoden, jedoch keineswegs für alle.

Ein alternativer Ansatz besteht darin, neue Metriken und Algorithmen zu entwickeln, die speziell für den TwoMode-Fall designed wurden. Das hört sich nach viel mehr Arbeit an, aber in der Praxis ist es oft möglich, Metriken anzupassen, die für allgemeine Diagramme ausgelegt sind, indem einfach eine entsprechende Post-hoc-Normalisierung angewendet wird. Besonders bei Zentralitätsmaßen ist das meist der bessere Weg.^[2: Theoretische und mathematische Hintergründe zu der Normalisierung von Netzwerkmaßen für bipartite Netzwerke findet man in Scott/Carrington: The SAGE Handbook of Social Network Analysis, 2011, S. 425f]

Im Degree-Fall ist es nicht sinnvoll, den einfachen Grad (Anzahl aller Verbindungen des Knotens) zu zählen und daraus die Dichte zu errechnen. Denn zwischen den Knoten einer Gruppe können ja gar keine Verbindungen bestehen. Eine sinnvolle Änderung ist es also, wenn die Dichte auf der Grundlage der Verbindungen besteht, die der Knoten mit der Gruppe des anderen Typs aufweist.

```{r}
density_bipartite <- function(graph) {
  if (is.directed(graph)) {
    ecount(graph) / sum(V(graph)$type) / sum(!V(graph)$type) / 2.0} 
  else {
    ecount(graph) / sum(V(graph)$type) / sum(!V(graph)$type)
  }
}

edge_density(rd_igraph)
density_bipartite(rd_igraph)
```

Auch bei der Closeness-Zentralität bietet sich eine Anpassung an. Diese wurde an dieser Stelle in ein externes Script ausgelagert (```bipartite_closeness_centrality.R```) und kann dort bei Bedarf nachvollzogen werden.

```{r}
source("bipartite_closeness_centrality.R")

bipartite_closeness_centrality(rd_igraph)

bipartite_closeness_centrality(rd_igraph) %>% unlist() %>% unname() %>% round(3) %>% as_tibble() %>% 
  mutate(name = V(rd_igraph)$name,
         type = case_when(V(rd_igraph)$type == TRUE ~ "eu",
                          TRUE ~ "non-eu")) %>% 
  select(name, closeness_centrality = value, type) %>%
  arrange(type, -closeness_centrality) %>% 
  datatable(options = list(pageLength = 20))
```

Gleiches gilt für die Betweenness-Zentralität:

```{r}
source("bipartite_betweenness_centrality.R")

bipartite_betweenness_centrality(rd_igraph)

bipartite_betweenness_centrality(rd_igraph) %>% unlist() %>% unname() %>% round(3) %>% as_tibble() %>% 
  mutate(name = V(rd_igraph)$name,
         type = case_when(V(rd_igraph)$type == TRUE ~ "eu",
                          TRUE ~ "non-eu")) %>% 
  select(name, betweenness_centrality = value, type) %>%
  arrange(type, -betweenness_centrality) %>% 
  datatable(options = list(pageLength = 20))
```


# Analyse der One-Mode-Projektionen

Die gemeinsame Untersuchung beider Knotentypen in einer Two-Mode-Netzwerkgrafik ist häufig der erste Schritt beim Studium eines Zugehörigkeitsnetzwerks. Es ist jedoch auch sinnvoll die One-Mode-Projektionen des Netzwerks zu untersuchen.
Die Funktion ```bipartite.projection``` gibt eine Liste von zwei igraph-Netzwerkobjekten zurück. Das erste Netzwerk besteht aus direkten Verbindungen zwischen dem ersten Modus und das zweite Netzwerk zeigt die Verbindungen zwischen dem zweiten Modus.

```{r}
rd_projection <- bipartite.projection(rd_igraph)
rd_projection


rd_hosts <- rd_projection$proj1
rd_eu28 <- rd_projection$proj2
```

```{r}
plot.igraph(rd_eu28)
plot.igraph(rd_hosts)
```

# Analyse des EU28-Netzwerks

Das EU28-Netzwerk ist ein Co-occurence-Netzwerk (One-Mode-Projektion des ursprünglichen Reisediplomatienetzwerks). Zwei Länder der EU28 haben dann eine Verbindung, wenn sie das gleiche Gastland besucht haben. Das Netzwerk ist ein ungerichtetes Netzwerk.

## Distances and paths

Die Länder die am wenigsten gemeinsame Besuchsländer hatten, lassen sich über den längsten Pfad im Netzwerk ermitteln. Das ist sozusagen der weiteste Abstand zwischen zwei Knoten, wenn jemand über die Kanten von einem zum anderen Knoten laufen wollen würde.

```{r}
farthest_vertices(rd_eu28)

mean_distance(rd_eu28, directed=FALSE)
```

## Welche Länder sind im Netzwerk besonders auffallend?

Es ist intuitiv sinnvoll, dass ein Netzwerkmitglied, das mit vielen anderen Mitgliedern des Netzwerks verbunden ist, eine herausragende Position einnimmt. Für nicht gerichtete Netzwerke sprechen wir von Akteuren mit einer hohen Zentralität.
Es gibt jedoch eine Reihe von Möglichkeiten, diese Art der Zentralität zu operationalisieren. Tatsächlich stehen in der Sozialen Netzwerkanalyse Dutzende von Zentralitätsstatistiken zur Verfügung.

### Degree centrality

Das einfachste Maß für die Zentralität basiert auf der Annahme, dass ein Knoten mit mehr direkten Bindungen stärker hervortritt als Knoten mit weniger oder keinen Bindungen. Diese Form nennt man degree centrality und entspricht einfach der Anzahl an Kanten. Alternativ lässt sich die Grad-Zentralität über einen Anteil der Verbindungen des Knotens an den gesamten Verbindungen ausdrücken.

```{r}
degree(rd_eu28)
r_degree <- degree(rd_eu28)

data.frame(r_degree)

plot.igraph(rd_eu28,
            vertex.size = r_degree*2)

hist(r_degree, breaks=1:vcount(rd_eu28)-1, main="Histogram of node degree")
```

### Closeness Centrality

Anstatt nur die direkten Verbindungen der Knoten zu untersuchen, können wir uns darauf konzentrieren, wie nahe sich jeder Knoten an jedem anderen Knoten in einem Netzwerk befindet. Dies führt zu dem Konzept der Closeness-Zentralität, wobei Knoten in dem Ausmaß, in dem sie sich in der Nähe aller anderen Knoten im Netzwerk befinden, eine größere Rolle spielen.

```{r}
r_closeness <- closeness(rd_eu28)
data.frame(r_closeness)
```

### Betweenness

Welche Knoten müssen am häufigsten durchlaufen werden? Die Betweenness-Zentralität misst das Ausmaß, in dem ein Knoten zwischen Paaren anderer Knoten im Netzwerk sitzt, so dass ein Pfad zwischen den anderen Knoten diesen Knoten durchlaufen muss. Ein Knoten mit einem hohen Wert ist daher interessant, weil dieser Knoten in der Lage ist, den Informationsfluss im Netzwerk zu beobachten oder zu steuern.

```{r}
r_betweenness <- igraph::betweenness(rd_eu28)
data.frame(r_betweenness)
```

Alle Ergebnisse gesammelt und in sortierbarer Tabelle:

```{r}
data.frame(r_degree,r_closeness,r_betweenness) %>% 
  round(digits = 4) %>% 
  datatable(iris,options = list(pageLength = 20))
```

```{r}
data.frame(r_degree,r_closeness,r_betweenness) %>%
  cor()
```


## Subgroups and communities

Cliques
```{r}
#cliques(rd_eu28) # list of cliques       

sapply(cliques(rd_eu28), length) # clique sizes

largest_cliques(rd_eu28)
```

```{r}
vcol <- rep("grey80", vcount(rd_eu28))
vcol[unlist(largest_cliques(rd_eu28))] <- "gold"
plot(as.undirected(rd_eu28), vertex.label=V(rd_eu28)$name, vertex.color=vcol)
```

Community detection
```{r}
ceb <- cluster_edge_betweenness(rd_eu28) 

dendPlot(ceb, mode="hclust")

plot(ceb,rd_eu28) 
```







